// Generated by Haxe 4.0.0 (git build development @ 3018ab109)
using haxe.root;

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace format.gif {
	public class Reader : global::haxe.lang.HxObject {
		
		public Reader(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public Reader(global::haxe.io.Input i) {
			global::format.gif.Reader.__hx_ctor_format_gif_Reader(this, i);
		}
		
		
		protected static void __hx_ctor_format_gif_Reader(global::format.gif.Reader __hx_this, global::haxe.io.Input i) {
			__hx_this.i = i;
			i.set_bigEndian(false);
		}
		
		
		public global::haxe.io.Input i;
		
		public virtual object read() {
			unchecked {
				{
					int _g = 0;
					global::haxe.root.Array<int> _g1 = new global::haxe.root.Array<int>(new int[]{71, 73, 70});
					while (( _g < _g1.length )) {
						int b = _g1[_g];
						 ++ _g;
						if (( this.i.readByte() != b )) {
							throw global::haxe.lang.HaxeException.wrap("Invalid header");
						}
						
					}
					
				}
				
				string gifVer = this.i.readString(3);
				global::format.gif.Version version = global::format.gif.Version.GIF89a;
				switch (gifVer) {
					case "87a":
					{
						version = global::format.gif.Version.GIF87a;
						break;
					}
					
					
					case "89a":
					{
						version = global::format.gif.Version.GIF89a;
						break;
					}
					
					
					default:
					{
						version = global::format.gif.Version.Unknown(gifVer);
						break;
					}
					
				}
				
				int width = this.i.readUInt16();
				int height = this.i.readUInt16();
				int packedField = this.i.readByte();
				int bgIndex = this.i.readByte();
				double pixelAspectRatio = ((double) (this.i.readByte()) );
				if (( pixelAspectRatio != 0 )) {
					pixelAspectRatio = ( (( pixelAspectRatio + 15 )) / 64 );
				}
				else {
					pixelAspectRatio = ((double) (1) );
				}
				
				object lsd = new global::haxe.lang.DynamicObject(new int[]{808948541, 2070785640}, new object[]{( (( packedField & 8 )) == 8 ), ( (( packedField & 128 )) == 128 )}, new int[]{38537191, 234855119, 623891245, 736935997, 1018258543, 1247983110}, new double[]{((double) (height) ), ((double) (( 2 << (( packedField & 7 )) )) ), pixelAspectRatio, ((double) (bgIndex) ), ((double) (((int) (( ((uint) ((( packedField & 112 ))) ) >> 4 )) )) ), ((double) (width) )});
				global::haxe.io.Bytes gct = null;
				if (global::haxe.lang.Runtime.toBool(global::haxe.lang.Runtime.getField(lsd, "hasGlobalColorTable", 2070785640, true))) {
					gct = this.readColorTable(((int) (global::haxe.lang.Runtime.getField_f(lsd, "globalColorTableSize", 234855119, true)) ));
				}
				
				global::haxe.ds.List<object> blocks = new global::haxe.ds.List<object>();
				while (true) {
					global::format.gif.Block b1 = this.readBlock();
					blocks.@add(b1);
					if (( b1 == global::format.gif.Block.BEOF )) {
						break;
					}
					
				}
				
				return new global::haxe.lang.DynamicObject(new int[]{146652910, 669658758, 2032764644, 2096228120}, new object[]{gct, blocks, lsd, version}, new int[]{}, new double[]{});
			}
		}
		
		
		public virtual global::format.gif.Block readBlock() {
			unchecked {
				int blockID = this.i.readByte();
				switch (blockID) {
					case 33:
					{
						return this.readExtension();
					}
					
					
					case 44:
					{
						return this.readImage();
					}
					
					
					case 59:
					{
						return global::format.gif.Block.BEOF;
					}
					
					
				}
				
				return global::format.gif.Block.BEOF;
			}
		}
		
		
		public virtual global::format.gif.Block readImage() {
			unchecked {
				int x = this.i.readUInt16();
				int y = this.i.readUInt16();
				int width = this.i.readUInt16();
				int height = this.i.readUInt16();
				int packed = this.i.readByte();
				bool localColorTable = ( (( packed & 128 )) == 128 );
				bool interlaced = ( (( packed & 64 )) == 64 );
				bool sorted = ( (( packed & 32 )) == 32 );
				int localColorTableSize = ( 2 << (( packed & 7 )) );
				global::haxe.io.Bytes lct = null;
				if (localColorTable) {
					lct = this.readColorTable(localColorTableSize);
				}
				
				object __temp_stmt2 = null;
				{
					global::haxe.io.Bytes __temp_odecl1 = this.readPixels(width, height, interlaced);
					__temp_stmt2 = new global::haxe.lang.DynamicObject(new int[]{212463405, 706588918, 793759659, 808948541, 1501088657}, new object[]{__temp_odecl1, localColorTable, lct, sorted, interlaced}, new int[]{120, 121, 38537191, 1247983110, 1584738519}, new double[]{((double) (x) ), ((double) (y) ), ((double) (height) ), ((double) (width) ), ((double) (localColorTableSize) )});
				}
				
				return global::format.gif.Block.BFrame(__temp_stmt2);
			}
		}
		
		
		public virtual global::haxe.io.Bytes readPixels(int width, int height, bool interlaced) {
			unchecked {
				global::haxe.io.Input input = this.i;
				int pixelsCount = ( width * height );
				global::haxe.io.Bytes pixels = global::haxe.io.Bytes.alloc(pixelsCount);
				int minCodeSize = input.readByte();
				int blockSize = ( input.readByte() - 1 );
				int bits = input.readByte();
				int bitsCount = 8;
				int clearCode = ( 1 << minCodeSize );
				int eoiCode = ( clearCode + 1 );
				int codeSize = ( minCodeSize + 1 );
				int codeSizeLimit = ( 1 << codeSize );
				int codeMask = ( codeSizeLimit - 1 );
				global::haxe.root.Array<object> baseDict = new global::haxe.root.Array<object>();
				{
					int _g1 = 0;
					int _g = clearCode;
					while (( _g1 < _g )) {
						int i = _g1++;
						baseDict[i] = new global::haxe.root.Array<int>(new int[]{i});
					}
					
				}
				
				global::haxe.root.Array<object> dict = new global::haxe.root.Array<object>();
				int dictLen = ( clearCode + 2 );
				global::haxe.root.Array<int> newRecord = null;
				int i1 = 0;
				int code = 0;
				int last = default(int);
				while (( i1 < pixelsCount )) {
					last = code;
					while (( bitsCount < codeSize )) {
						if (( blockSize == 0 )) {
							break;
						}
						
						bits |= ( input.readByte() << bitsCount );
						bitsCount += 8;
						 -- blockSize;
						if (( blockSize == 0 )) {
							blockSize = input.readByte();
						}
						
					}
					
					code = ( bits & codeMask );
					bits >>= codeSize;
					bitsCount -= codeSize;
					if (( code == clearCode )) {
						dict = baseDict.copy();
						dictLen = ( clearCode + 2 );
						codeSize = ( minCodeSize + 1 );
						codeSizeLimit = ( 1 << codeSize );
						codeMask = ( codeSizeLimit - 1 );
						continue;
					}
					
					if (( code == eoiCode )) {
						break;
					}
					
					if (( code < dictLen )) {
						if (( last != clearCode )) {
							newRecord = ((global::haxe.root.Array<int>) (global::haxe.root.Array<object>.__hx_cast<int>(((global::haxe.root.Array) (dict[last]) ))) ).copy();
							newRecord.push(((global::haxe.root.Array<int>) (global::haxe.root.Array<object>.__hx_cast<int>(((global::haxe.root.Array) (dict[code]) ))) )[0]);
							dict[dictLen++] = newRecord;
						}
						
					}
					else {
						if (( code != dictLen )) {
							throw global::haxe.lang.HaxeException.wrap(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("Invalid LZW code. Excepted: ", global::haxe.lang.Runtime.toString(dictLen)), ", got: "), global::haxe.lang.Runtime.toString(code)));
						}
						
						newRecord = ((global::haxe.root.Array<int>) (global::haxe.root.Array<object>.__hx_cast<int>(((global::haxe.root.Array) (dict[last]) ))) ).copy();
						newRecord.push(newRecord[0]);
						dict[dictLen++] = newRecord;
					}
					
					newRecord = ((global::haxe.root.Array<int>) (global::haxe.root.Array<object>.__hx_cast<int>(((global::haxe.root.Array) (dict[code]) ))) );
					{
						int _g2 = 0;
						while (( _g2 < newRecord.length )) {
							int item = newRecord[_g2];
							 ++ _g2;
							pixels.b[i1++] = ((byte) (item) );
						}
						
					}
					
					if (( ( dictLen == codeSizeLimit ) && ( codeSize < 12 ) )) {
						 ++ codeSize;
						codeSizeLimit = ( 1 << codeSize );
						codeMask = ( codeSizeLimit - 1 );
					}
					
				}
				
				while (( blockSize > 0 )) {
					input.readByte();
					 -- blockSize;
					if (( blockSize == 0 )) {
						blockSize = input.readByte();
					}
					
				}
				
				while (( i1 < pixelsCount )) {
					pixels.b[i1++] = ((byte) (0) );
				}
				
				if (interlaced) {
					global::haxe.io.Bytes buffer = global::haxe.io.Bytes.alloc(pixelsCount);
					int offset = this.deinterlace(pixels, buffer, 8, 0, 0, width, height);
					offset = this.deinterlace(pixels, buffer, 8, 4, offset, width, height);
					offset = this.deinterlace(pixels, buffer, 4, 2, offset, width, height);
					this.deinterlace(pixels, buffer, 2, 1, offset, width, height);
					pixels = buffer;
				}
				
				return pixels;
			}
		}
		
		
		public virtual int deinterlace(global::haxe.io.Bytes input, global::haxe.io.Bytes output, int step, int y, int offset, int width, int height) {
			while (( y < height )) {
				output.blit(( y * width ), input, offset, width);
				offset += width;
				y += step;
			}
			
			return offset;
		}
		
		
		public virtual global::format.gif.Block readExtension() {
			unchecked {
				int subId = this.i.readByte();
				switch (subId) {
					case 1:
					{
						if (( this.i.readByte() != 12 )) {
							throw global::haxe.lang.HaxeException.wrap("Incorrect size of Plain Text Extension introducer block.");
						}
						
						int tmp = this.i.readUInt16();
						int tmp1 = this.i.readUInt16();
						int tmp2 = this.i.readUInt16();
						int tmp3 = this.i.readUInt16();
						int tmp4 = this.i.readByte();
						int tmp5 = this.i.readByte();
						int tmp6 = this.i.readByte();
						int tmp7 = this.i.readByte();
						global::haxe.io.BytesOutput buffer = new global::haxe.io.BytesOutput();
						global::haxe.io.Bytes bytes = global::haxe.io.Bytes.alloc(255);
						int len = this.i.readByte();
						while (( len != 0 )) {
							this.i.readBytes(bytes, 0, len);
							buffer.writeBytes(bytes, 0, len);
							len = this.i.readByte();
						}
						
						buffer.flush();
						bytes = buffer.getBytes();
						buffer.close();
						object __temp_stmt5 = null;
						{
							string __temp_odecl1 = bytes.toString();
							__temp_stmt5 = new global::haxe.lang.DynamicObject(new int[]{1291439277}, new object[]{__temp_odecl1}, new int[]{31706958, 89406858, 555415130, 853386981, 853386982, 1539378591, 1740766879, 1991808755}, new double[]{((double) (tmp4) ), ((double) (tmp7) ), ((double) (tmp3) ), ((double) (tmp) ), ((double) (tmp1) ), ((double) (tmp5) ), ((double) (tmp6) ), ((double) (tmp2) )});
						}
						
						global::format.gif.Extension __temp_stmt4 = global::format.gif.Extension.EText(__temp_stmt5);
						return global::format.gif.Block.BExtension(__temp_stmt4);
					}
					
					
					case 249:
					{
						if (( this.i.readByte() != 4 )) {
							throw global::haxe.lang.HaxeException.wrap("Incorrect Graphic Control Extension block size!");
						}
						
						int packed = this.i.readByte();
						global::format.gif.DisposalMethod disposalMethod = null;
						int _g = ( (( packed & 28 )) >> 2 );
						switch (_g) {
							case 0:
							{
								disposalMethod = global::format.gif.DisposalMethod.UNSPECIFIED;
								break;
							}
							
							
							case 1:
							{
								disposalMethod = global::format.gif.DisposalMethod.NO_ACTION;
								break;
							}
							
							
							case 2:
							{
								disposalMethod = global::format.gif.DisposalMethod.FILL_BACKGROUND;
								break;
							}
							
							
							case 3:
							{
								disposalMethod = global::format.gif.DisposalMethod.RENDER_PREVIOUS;
								break;
							}
							
							
							default:
							{
								disposalMethod = global::format.gif.DisposalMethod.UNDEFINED(( (( packed & 28 )) >> 2 ));
								break;
							}
							
						}
						
						object __temp_stmt7 = null;
						{
							int __temp_odecl2 = this.i.readUInt16();
							int __temp_odecl3 = this.i.readByte();
							__temp_stmt7 = new global::haxe.lang.DynamicObject(new int[]{701242674, 755457067, 1743811007}, new object[]{disposalMethod, ( (( packed & 1 )) == 1 ), ( (( packed & 2 )) == 2 )}, new int[]{772773472, 1462163331}, new double[]{((double) (__temp_odecl3) ), ((double) (__temp_odecl2) )});
						}
						
						global::format.gif.Extension __temp_stmt6 = global::format.gif.Extension.EGraphicControl(__temp_stmt7);
						global::format.gif.Block b = global::format.gif.Block.BExtension(__temp_stmt6);
						this.i.readByte();
						return b;
					}
					
					
					case 254:
					{
						global::haxe.io.BytesOutput buffer1 = new global::haxe.io.BytesOutput();
						global::haxe.io.Bytes bytes1 = global::haxe.io.Bytes.alloc(255);
						int len1 = this.i.readByte();
						while (( len1 != 0 )) {
							this.i.readBytes(bytes1, 0, len1);
							buffer1.writeBytes(bytes1, 0, len1);
							len1 = this.i.readByte();
						}
						
						buffer1.flush();
						bytes1 = buffer1.getBytes();
						buffer1.close();
						return global::format.gif.Block.BExtension(global::format.gif.Extension.EComment(bytes1.toString()));
					}
					
					
					case 255:
					{
						return this.readApplicationExtension();
					}
					
					
					default:
					{
						global::haxe.io.BytesOutput buffer2 = new global::haxe.io.BytesOutput();
						global::haxe.io.Bytes bytes2 = global::haxe.io.Bytes.alloc(255);
						int len2 = this.i.readByte();
						while (( len2 != 0 )) {
							this.i.readBytes(bytes2, 0, len2);
							buffer2.writeBytes(bytes2, 0, len2);
							len2 = this.i.readByte();
						}
						
						buffer2.flush();
						bytes2 = buffer2.getBytes();
						buffer2.close();
						return global::format.gif.Block.BExtension(global::format.gif.Extension.EUnknown(subId, bytes2));
					}
					
				}
				
			}
		}
		
		
		public virtual global::format.gif.Block readApplicationExtension() {
			unchecked {
				if (( this.i.readByte() != 11 )) {
					throw global::haxe.lang.HaxeException.wrap("Incorrect size of Application Extension introducer block.");
				}
				
				string name = this.i.readString(8);
				string version = this.i.readString(3);
				global::haxe.io.BytesOutput buffer = new global::haxe.io.BytesOutput();
				global::haxe.io.Bytes bytes = global::haxe.io.Bytes.alloc(255);
				int len = this.i.readByte();
				while (( len != 0 )) {
					this.i.readBytes(bytes, 0, len);
					buffer.writeBytes(bytes, 0, len);
					len = this.i.readByte();
				}
				
				buffer.flush();
				bytes = buffer.getBytes();
				buffer.close();
				global::haxe.io.Bytes data = bytes;
				if (( ( ( name == "NETSCAPE" ) && ( version == "2.0" ) ) && ( ((int) (data.b[0]) ) == 1 ) )) {
					return global::format.gif.Block.BExtension(global::format.gif.Extension.EApplicationExtension(global::format.gif.ApplicationExtension.AENetscapeLooping(( ((int) (data.b[1]) ) | ( ((int) (data.b[2]) ) << 8 ) ))));
				}
				
				return global::format.gif.Block.BExtension(global::format.gif.Extension.EApplicationExtension(global::format.gif.ApplicationExtension.AEUnknown(name, version, data)));
			}
		}
		
		
		public global::haxe.io.Bytes readBlocks() {
			unchecked {
				global::haxe.io.BytesOutput buffer = new global::haxe.io.BytesOutput();
				global::haxe.io.Bytes bytes = global::haxe.io.Bytes.alloc(255);
				int len = this.i.readByte();
				while (( len != 0 )) {
					this.i.readBytes(bytes, 0, len);
					buffer.writeBytes(bytes, 0, len);
					len = this.i.readByte();
				}
				
				buffer.flush();
				bytes = buffer.getBytes();
				buffer.close();
				return bytes;
			}
		}
		
		
		public virtual global::haxe.io.Bytes readColorTable(int size) {
			unchecked {
				size *= 3;
				global::haxe.io.Bytes output = global::haxe.io.Bytes.alloc(size);
				int c = 0;
				while (( c < size )) {
					{
						int v = this.i.readByte();
						output.b[c] = ((byte) (v) );
					}
					
					{
						int v1 = this.i.readByte();
						output.b[( c + 1 )] = ((byte) (v1) );
					}
					
					{
						int v2 = this.i.readByte();
						output.b[( c + 2 )] = ((byte) (v2) );
					}
					
					c += 3;
				}
				
				return output;
			}
		}
		
		
		public override object __hx_setField(string field, int hash, object @value, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 105:
					{
						this.i = ((global::haxe.io.Input) (@value) );
						return @value;
					}
					
					
					default:
					{
						return base.__hx_setField(field, hash, @value, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_getField(string field, int hash, bool throwErrors, bool isCheck, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 478930593:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "readColorTable", 478930593)) );
					}
					
					
					case 560337532:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "readBlocks", 560337532)) );
					}
					
					
					case 1030456453:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "readApplicationExtension", 1030456453)) );
					}
					
					
					case 2021592393:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "readExtension", 2021592393)) );
					}
					
					
					case 1913956818:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "deinterlace", 1913956818)) );
					}
					
					
					case 103142179:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "readPixels", 103142179)) );
					}
					
					
					case 240151589:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "readImage", 240151589)) );
					}
					
					
					case 98812439:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "readBlock", 98812439)) );
					}
					
					
					case 1269254998:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "read", 1269254998)) );
					}
					
					
					case 105:
					{
						return this.i;
					}
					
					
					default:
					{
						return base.__hx_getField(field, hash, throwErrors, isCheck, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_invokeField(string field, int hash, object[] dynargs) {
			unchecked {
				switch (hash) {
					case 478930593:
					{
						return this.readColorTable(((int) (global::haxe.lang.Runtime.toInt(dynargs[0])) ));
					}
					
					
					case 560337532:
					{
						return this.readBlocks();
					}
					
					
					case 1030456453:
					{
						return this.readApplicationExtension();
					}
					
					
					case 2021592393:
					{
						return this.readExtension();
					}
					
					
					case 1913956818:
					{
						return this.deinterlace(((global::haxe.io.Bytes) (dynargs[0]) ), ((global::haxe.io.Bytes) (dynargs[1]) ), ((int) (global::haxe.lang.Runtime.toInt(dynargs[2])) ), ((int) (global::haxe.lang.Runtime.toInt(dynargs[3])) ), ((int) (global::haxe.lang.Runtime.toInt(dynargs[4])) ), ((int) (global::haxe.lang.Runtime.toInt(dynargs[5])) ), ((int) (global::haxe.lang.Runtime.toInt(dynargs[6])) ));
					}
					
					
					case 103142179:
					{
						return this.readPixels(((int) (global::haxe.lang.Runtime.toInt(dynargs[0])) ), ((int) (global::haxe.lang.Runtime.toInt(dynargs[1])) ), global::haxe.lang.Runtime.toBool(dynargs[2]));
					}
					
					
					case 240151589:
					{
						return this.readImage();
					}
					
					
					case 98812439:
					{
						return this.readBlock();
					}
					
					
					case 1269254998:
					{
						return this.read();
					}
					
					
					default:
					{
						return base.__hx_invokeField(field, hash, dynargs);
					}
					
				}
				
			}
		}
		
		
		public override void __hx_getFields(global::haxe.root.Array<object> baseArr) {
			baseArr.push("i");
			base.__hx_getFields(baseArr);
		}
		
		
	}
}


